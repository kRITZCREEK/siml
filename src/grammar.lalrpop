use crate::token::Token;
use crate::expr::{Expr, Literal};
use crate::types::{Type};
use crate::bi_types;

grammar;

extern {
    enum Token {
        "identifier" => Token::Ident(<String>),
        "int_literal" => Token::IntLiteral(<i32>),
        "bool_literal" => Token::BooleanLiteral(<bool>),
        "forall" => Token::Forall,
        "let" => Token::Let,
        "in" => Token::In,
        "=" => Token::Equals,
        "\\" => Token::Lambda,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "." => Token::Dot,
        "->" => Token::Arrow,
        ":" => Token::Colon,
    }
}

pub Expr: Expr = {
    ExprAtom,
    "\\" <binder: "identifier"> "." <body: Expr> =>
        Expr::Lambda { binder: binder.to_string(), body: Box::new(body) },
    "let" <binder: "identifier"> "=" <expr: Expr> "in" <body: Expr> =>
        Expr::Let { binder: binder.to_string(), expr: Box::new(expr), body: Box::new(body) },
    <function: ExprAtom> <arguments: ExprAtom+> => {
        arguments
          .into_iter()
          .fold(function, |acc, x| Expr::App { func: Box::new(acc), arg: Box::new(x) })
    },
}


ExprAtom: Expr = {
    <i:"identifier"> => Expr::Var(i.to_string()),
    "int_literal" => Expr::Literal(Literal::Int(<>)),
    "bool_literal" => Expr::Literal(Literal::Bool(<>)),
    "(" <e:Expr> ":" <t:BiType> ")" => Expr::Ann{ ty: t, expr: Box::new(e) },
    "(" <e:Expr> ")" => e,
};

pub Type: Type = {
    BiType => {
        Type::from_bi_type(<>)
    }
}

pub BiType: bi_types::Type = {
    "forall" <vars: "identifier"+> "." <ty: BiType> => {
        bi_types::Type::Poly {vars, ty: Box::new(ty)}
    },
    <arg: TypeAtom> "->" <result: BiType> => {
        bi_types::Type::Fun {arg: Box::new(arg), result: Box::new(result)}
    },
    TypeAtom
}

TypeAtom: bi_types::Type = {
    "(" <t:BiType> ")" => t,
    <i:"identifier"> => {
        match i.as_ref() {
          "Int" => bi_types::Type::Int,
          "Bool" => bi_types::Type::Bool,
          _ => bi_types::Type::Var(i),
        }
    }
}
